finaltraitvals
testtips[1].height
fieldnames(typeof(testtips[1]))
testtips[1].inbound.data["1"].t[end]
 testtips[i].inbound.data["1"].t[end]
 testtips[1].inbound.data["1"].t[end]
i = 1
 testtips[1].inbound.data["1"].t[end]
typeof(tiptimes)
typeof(testtips[i].inbound.data["1"].t[end])
finaltraitvals
tiptimes
tiptimesdict
tiptimesdict[1]
exit()
ls()
ls
list()
list.files()
Pkg.add("Distances") #if you don't have it
using Distances
y
euclidean(rand(10), rand(10))
finaltraitvals
tipnamesdict
tiptimesdict
keys(tiptimesdict)
valuestiptimesdict
values(tiptimesdict)
keys(finaltraitvalues)
keys(finaltraitvals)
values(finaltraitvals)
?order
res
tipnames
plot(tree)
fieldnames(typeof(tree))
testtips
tiptimes
v1 = rand(4)
v2 = rand(4)
euclidean(v1, v2)
squaredeuclidean(v1, v2)
euclidean(v1, v2)
 collect(Iterators.flatten(Iterators.flatten(finaltraitvals)))
 collect(Iterators.flatten(Iterators.flatten(res)))
vals
vals = rand(400)
euclidean(vals, resvalsflat)
euclidean(vals, resvalsflat)
[24, 24, 234]
[24, 24, 234]'
res
finaltraitvals
collect(Iterators.flatten(res))
mat
dim(mat)
diffusion(5, 1)
P
P
p
tree
x0
mat
tree
fieldnames(typeof(tree))
tree.tipdata
getheight(tree)
tree
getheight(tree, node.)))
diffusion(x0, tspand)
diffusion(x0, tspan)
test
menura(tree, x0, mat)
predictTraitTree(tree, x0, mat)
tree
x0
mat
tiptimes
tree
remove(p)
menura(tree, x0, mat, p)
diffusion(x0, tspan, mat, p)
diffusion(x0, tspan, mat, p)
x0
tspan
mat
p
diffusion(x0, tspan, p)
menura(tree)
tree
simulation(x0, mat, tspan, p)
simulation(x0, mat, tspan, p)
x0
mat
p
tree
x0
mat
p
simulation(x0, mat, tspan, p)
p
x0
simulation(x0, mat, tspan, p)
ones(5)
simulation(x0, mat, tspan, p)
p[1]
simulation(x0, mat, tspan, p)
diffusion(x0, tspan, p)
diffusion(x0, tspan, p)
simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
round(-0.00006)
abs(-.4)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
diffusion(x0, tspan, p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diag(4)
I
using LinearAlgebra
I
I[4,4]
I
test = simulation(x0, mat, tspan, p)
I
I3.5
0.5I
test = simulation(x0, mat, tspan, p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 100.0), p)
diffusion(x0, (0.0, 100.0), p)
diffusion(x0, (0.0, 100.0), p)
diffusion(x0, (0.0, 100.0), p)
diffusion(x0, (0.0, 100.0), p)
sigma
sigma_vec
diffusion(x0, (0.0, 100.0), p)
diffusion(x0, (0.0, 100.0), p)
diffusion(x0, (0.0, 100.0), p)
diffusion(x0, (0.0, 100.0), p)
diffusion(x0, (0.0, 100.0), p)
round(-0.00001)
sqrt(round(-0.00001))
diffusion(x0, (0.0, 100.0), p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, (0.0, 100.0), p)
test = simulation(x0, mat, (0.0, 100.0), p)
tspan
tspan
plot(tree)
tree.plot
fieldnames(typeof(tree))
tree.data
tree.tipdata
tree.nodes
?"Ultrametric"
plot(tr)
Exponential(3)
exp(23)
heights(test)
tree
heights(tree)
using Phylo;
height(tree)
height(tr)
tree.heightstoRoot
tree.heightstotoot
tree.heightstoroot
heightstoroot(tree)
heightstoroot(tree)
heightstoroot(tree).x
heightstoroot(tree).x
heightstoroot(tree)
tst = heightstoroot(tree)
test
tst
tst.x
fieldnames(typeof(tst))
tst.data
tst.axes
tst.axes[1]
tst.axes[1][1]
tst.data[1][1]
tst.data[1]
tst.data
include("testJulia3.jl")
include("testJulia3.jl")
exit()
include("testJulia3.jl")
whos()
whos()
whos()
using JLD2
include("testJulia3.jl")
whos()
who()
whos
include("testJulia3.jl")
varinfo()
@save "test.jld"
exit()
using JLD2
@load "test.jld"
include("testJulia3.jl")
varinfo()
@save "test.jld"
exit()
using JLD2
@load "test.jld"
<<<<<<< Updated upstream
=======
exit()
>>>>>>> Stashed changes
import Pkg; Pkg.add("Distances")
p
<<<<<<< HEAD
=======
>>>>>>> Stashed changes
=======
>>>>>>> main
=======
q()
exit()
>>>>>>> Stashed changes
exit()
plot(test)
test
exit()
x0
using Phylo
plot(tree)
plot(tree)
menura(tree, x0, mat, p, t0=0.0, dt=0.001)
)
typeof(mu1)
using Distributions
using KissABC
prior=Factored(Uniform(1,3), Truncated(Normal(0,0.1), 0, 100))
using KissABC
prior=Factored(Uniform(1,3), Truncated(Normal(0,0.1), 0, 100))
Factored(Truncated(Normal(0, 10), 0),
                 Truncated(Normal(0, 10), 0))
Factored(Truncated(Normal(0, 10), 0))
Truncated(Normal(0, 10), 0)
prior = Truncated(Normal(0.0, 10.0), l=0.0, u=Inf)

prior = Truncated(Normal(0.0, 10.0),0.0, Inf)
exit()
exit()
]
exit()
import Pkg; Pkg.add("PyPlot")
rand(prior1)
rand(prior1)
rand(prior1)
rand(prior1)
exit()
typeof(prior1)
Array{Factored{3}}(undef, 4)
sz
length(alpha_vec)
ndims
npar
priors
 ERROR: UndefVarError: ESS not defined
rand(priors)
rand.(priors)
rand.(priors)
rand(priors[1])
priors
rand.(priors)
priors
rand.(sigma)
sigma
flatten(rand.(alpha))
collect(rand.(alpha))
rand.(alpha)
rand.(alpha)
rand.(alpha)[1,]
rand.(alpha)[1,][1]
rand.(alpha)
i for 1 in rand.(alpha)
[i for 1 in rand.(alpha)]
[i for i in rand.(alpha)]
[i for i in rand.(alpha)[i]]
q()
exit()
tree
x0
length(x)
rand(x0)
x0
rand(Normal(10))
rand(Normal(10, 100))
rand(Normal(10, 100,3))
priors
alpha1
priors = [alpha1, mu1, sigma1]
priors = [alpha1 mu1 sigma1]
priors = [alpha1, mu1, sigma1]
approx_density = ApproxKernelizedPosterior(priors,cost,0.005)
prior=Factored(Uniform(1,3), Truncated(Normal(0,0.1), 0, 100))
ndims
rand(priors)
rand(priors)
tst = smc(priors, cost)
typeof(priors)
prior=Factored(Uniform(1,3), Truncated(Normal(0,0.1), 0, 100))
typeof(prior)
typeof(priors)
sample(priors)
rand(priors)
simulation(alpha1, mu1, sigma1)
y
euclidean(x, y)
x
y
alpha1
exit()
ts <- (1,2,3,4)
tst = (1,2,3,4)
tst[1]
tst[4]
thetuple
tuple
tst[3:4]
p
alpha1
mu1
plot(res)
res
typeof(res)
res[1]
res[1][1]
res[1].particles
stephist(res[1].particles)
plot(res[1].particles)
plot(res[4].particles)
plot(res[7].particles)
plot(res[1].particles)
plot(res[1].particles)
stephist(res[1].particles)
priors
priors[1]
priors.p
priors.p[1]
typeof(priors)
priors.p[3]
?istuple
?is_tuple
test.p = (1,2)
test =()
test.p = (1,2)
plot(res[1].particles)
plot(res[4].particles)
plot(res[8].particles)
plot(res[12].particles)
ressmc
ressmc.p
typeof(ressmc)
ressmc.P
ressmc.W
ressmc.Ïµ
ressmc.P
ressmc.P[1]
ressmc.P[1]
ressmc
rssmc.P[1:100]
ressmc.P[1:100]
ressmc.P
ressmc.A
ressmc.P.A
fieldnames(ressmc)
ABCDE()
rand(priors)
Threads.nthreads()
exit()
Threads.nthreads()
Threads.nthreads()
exit()
Threads.nthreads()
priordists
rand(priordists)
rand(priordists)
repeat(priordists, 12)
repeat((priordists), 12)
priors
using JLD2
y
using JLD2
save_object("ABCResults.jld2", res)
test = read("ABCResults.jld2")
test
using JLD2
res
load_object("ABCResults.jld2")
exit()
p[4]
using Distributions
rand(InverseWishart(mat, 10))
using Distributions
rand(InverseWishart(mat, 10))
rand(InverseWishart(10, mat))
mat
rand(InverseWishart(1000, mat))
rand(InverseWishart(3, mat))
rand(InverseWishart(4, mat))
tst = rand(InverseWishart(4, mat))
tst/diag(tst)
tst/diagonal(tst)
cor(InverseWishart(4, mat))
using StatsBase
y
cor(InverseWishart(4, mat))
cor(InverseWishart)
mat
mat/3.0
mat
dim
dim(mat)
using LinearAlgebra
Diagonal(mat)
?repeat
using LinearAlgebra
Is = sqrt.(1.0/Diagonal(mat))
Is = sqrt.(1.0/.Diagonal(mat))
Is = sqrt.(1.0 ./ Diagonal(mat))
mat
mat
Is
mat
cov2cor(mat, Diagonal(mat))
cov2cor(mat, [1,1,1,1])
mat
diag(mat)
cov2cor(mat, diag(mat))
q()
exit()
