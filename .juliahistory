testtips[1].inbound
testtips[1].inbound.data
testtips[1].inbound.data["1"].u
testtips[1].inbound.data["1"].u
res
a = Vector(Float64, 3)
a = Vector{Float64, 3}
a = Vector{Float64}
a[1] = .39587
a
a[]
myvec = a[1:10]
res[1]
res[1:3] = [.3534 .35454 .354]
C = Array{Float64}[] 
C = Array{Float64, 4}[] 
C[1] = [239874 23487 34587987]
C[1] = [239874, 23487, 34587987]
C = Array{Float64, undef, 0, 0}
C = Array{Float64}(undef, 0, 0}
C = Array{Float64}(undef, 0, 0)
C = Array{Float64}(undef, 15, 1)
C[1] = [234 432 213 123]
C = Array{Matrix{Float64}}}(undef, 15, 1)
C = Array{Matrix{Float64}}(undef, 15, 1)
C[1] = [243 24 25 123]
C
length(testtips)
length(res)
length(res)
res[1]
res[1,1]
typof(res)
typeof(res)
C = Array{Matrix{Float64}}(undef, 15, 1)
C[1]
C[1,1]
C(1,1)
C[1]
C[,1]
C[:1]
C = Array{Matrix{Float64}}[undef, 15, 1]
C = Array{Matrix{Float64}}(undef, 15, 1)
C[1] = .4
C[1] = [.3 .4]
C[2] = [.3 .4]
C[2] = [.3 .4, .3]
C[2] = [.3 .4 .3]
C
length(testtips)
finaltraitvals
finaltraitvals'
as.matrix(final.traitvals)
[finaltraitvals]
typeof(finaltraitvals)
res
res
fieldnames(testtips[1])
fieldnames(testtips)
fieldnames(typeof(testtips))
fieldnames(typeof(testbranches))
testbranches.x
test.branches.x[3]
test.branches[3].x
fieldnames(typeof(testbranches))
testbranches.x
testbranches.x[1]
[100]
testbranches.x[100]
testbranches.x[394]
fieldnames(typeof(testtips))
fieldnames(typeof(testtips[1]))
testtips[1].name
res
tipnames
tipnames[1] = "i"
tipnames
tipnames
Array()
vcat(res, tipnames)
hcat(res, tipnames)
endtraits["tip 1"]
mydict
tipnames
res
mydict
mydict["tip 4"]
tipnames[4]
res[4]
res
 testtips[1].inbound.data["1"].t[end]
 testtips[1].inbound.data["1"].t[end]
finaltipnames
finaltraitvals
finaltraitvals
finaltraitvals
finaltraitvals
testtips[1].height
fieldnames(typeof(testtips[1]))
testtips[1].inbound.data["1"].t[end]
 testtips[i].inbound.data["1"].t[end]
 testtips[1].inbound.data["1"].t[end]
i = 1
 testtips[1].inbound.data["1"].t[end]
typeof(tiptimes)
typeof(testtips[i].inbound.data["1"].t[end])
finaltraitvals
tiptimes
tiptimesdict
tiptimesdict[1]
exit()
ls()
ls
list()
list.files()
Pkg.add("Distances") #if you don't have it
using Distances
y
euclidean(rand(10), rand(10))
finaltraitvals
tipnamesdict
tiptimesdict
keys(tiptimesdict)
valuestiptimesdict
values(tiptimesdict)
keys(finaltraitvalues)
keys(finaltraitvals)
values(finaltraitvals)
?order
res
tipnames
plot(tree)
fieldnames(typeof(tree))
testtips
tiptimes
v1 = rand(4)
v2 = rand(4)
euclidean(v1, v2)
squaredeuclidean(v1, v2)
euclidean(v1, v2)
 collect(Iterators.flatten(Iterators.flatten(finaltraitvals)))
 collect(Iterators.flatten(Iterators.flatten(res)))
vals
vals = rand(400)
euclidean(vals, resvalsflat)
euclidean(vals, resvalsflat)
[24, 24, 234]
[24, 24, 234]'
res
finaltraitvals
collect(Iterators.flatten(res))
mat
dim(mat)
diffusion(5, 1)
P
P
p
tree
x0
mat
tree
fieldnames(typeof(tree))
tree.tipdata
getheight(tree)
tree
getheight(tree, node.)))
diffusion(x0, tspand)
diffusion(x0, tspan)
test
menura(tree, x0, mat)
predictTraitTree(tree, x0, mat)
tree
x0
mat
tiptimes
tree
remove(p)
menura(tree, x0, mat, p)
diffusion(x0, tspan, mat, p)
diffusion(x0, tspan, mat, p)
x0
tspan
mat
p
diffusion(x0, tspan, p)
menura(tree)
tree
simulation(x0, mat, tspan, p)
simulation(x0, mat, tspan, p)
x0
mat
p
tree
x0
mat
p
simulation(x0, mat, tspan, p)
p
x0
simulation(x0, mat, tspan, p)
ones(5)
simulation(x0, mat, tspan, p)
p[1]
simulation(x0, mat, tspan, p)
diffusion(x0, tspan, p)
diffusion(x0, tspan, p)
simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
round(-0.00006)
abs(-.4)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
diffusion(x0, tspan, p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diag(4)
I
using LinearAlgebra
I
I[4,4]
I
test = simulation(x0, mat, tspan, p)
I
I3.5
0.5I
test = simulation(x0, mat, tspan, p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 10.0), p)
diffusion(x0, (0.0, 100.0), p)
diffusion(x0, (0.0, 100.0), p)
diffusion(x0, (0.0, 100.0), p)
diffusion(x0, (0.0, 100.0), p)
diffusion(x0, (0.0, 100.0), p)
sigma
sigma_vec
diffusion(x0, (0.0, 100.0), p)
diffusion(x0, (0.0, 100.0), p)
diffusion(x0, (0.0, 100.0), p)
diffusion(x0, (0.0, 100.0), p)
diffusion(x0, (0.0, 100.0), p)
round(-0.00001)
sqrt(round(-0.00001))
diffusion(x0, (0.0, 100.0), p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, tspan, p)
test = simulation(x0, mat, (0.0, 100.0), p)
test = simulation(x0, mat, (0.0, 100.0), p)
tspan
tspan
plot(tree)
tree.plot
fieldnames(typeof(tree))
tree.data
tree.tipdata
tree.nodes
?"Ultrametric"
plot(tr)
Exponential(3)
exp(23)
heights(test)
tree
heights(tree)
using Phylo;
height(tree)
height(tr)
tree.heightstoRoot
tree.heightstotoot
tree.heightstoroot
heightstoroot(tree)
heightstoroot(tree)
heightstoroot(tree).x
heightstoroot(tree).x
heightstoroot(tree)
tst = heightstoroot(tree)
test
tst
tst.x
fieldnames(typeof(tst))
tst.data
tst.axes
tst.axes[1]
tst.axes[1][1]
tst.data[1][1]
tst.data[1]
tst.data
include("testJulia3.jl")
include("testJulia3.jl")
exit()
include("testJulia3.jl")
whos()
whos()
whos()
using JLD2
include("testJulia3.jl")
whos()
who()
whos
include("testJulia3.jl")
varinfo()
@save "test.jld"
exit()
using JLD2
@load "test.jld"
include("testJulia3.jl")
varinfo()
@save "test.jld"
exit()
using JLD2
@load "test.jld"
<<<<<<< Updated upstream
=======
exit()
>>>>>>> Stashed changes
import Pkg; Pkg.add("Distances")
p
<<<<<<< HEAD
=======
>>>>>>> Stashed changes
=======
>>>>>>> main
=======
q()
exit()
>>>>>>> Stashed changes
exit()
plot(test)
test
exit()
x0
using Phylo
plot(tree)
plot(tree)
menura(tree, x0, mat, p, t0=0.0, dt=0.001)
)
typeof(mu1)
using Distributions
using KissABC
prior=Factored(Uniform(1,3), Truncated(Normal(0,0.1), 0, 100))
using KissABC
prior=Factored(Uniform(1,3), Truncated(Normal(0,0.1), 0, 100))
Factored(Truncated(Normal(0, 10), 0),
                 Truncated(Normal(0, 10), 0))
Factored(Truncated(Normal(0, 10), 0))
Truncated(Normal(0, 10), 0)
prior = Truncated(Normal(0.0, 10.0), l=0.0, u=Inf)

prior = Truncated(Normal(0.0, 10.0),0.0, Inf)
exit()
exit()
]
exit()
import Pkg; Pkg.add("PyPlot")
rand(prior1)
rand(prior1)
rand(prior1)
rand(prior1)
exit()
typeof(prior1)
Array{Factored{3}}(undef, 4)
sz
length(alpha_vec)
ndims
npar
priors
 ERROR: UndefVarError: ESS not defined
rand(priors)
rand.(priors)
rand.(priors)
rand(priors[1])
priors
rand.(priors)
priors
rand.(sigma)
sigma
flatten(rand.(alpha))
collect(rand.(alpha))
rand.(alpha)
rand.(alpha)
rand.(alpha)[1,]
rand.(alpha)[1,][1]
rand.(alpha)
i for 1 in rand.(alpha)
[i for 1 in rand.(alpha)]
[i for i in rand.(alpha)]
[i for i in rand.(alpha)[i]]
q()
exit()
tree
x0
length(x)
rand(x0)
x0
rand(Normal(10))
rand(Normal(10, 100))
rand(Normal(10, 100,3))
priors
alpha1
priors = [alpha1, mu1, sigma1]
priors = [alpha1 mu1 sigma1]
priors = [alpha1, mu1, sigma1]
approx_density = ApproxKernelizedPosterior(priors,cost,0.005)
prior=Factored(Uniform(1,3), Truncated(Normal(0,0.1), 0, 100))
ndims
rand(priors)
rand(priors)
tst = smc(priors, cost)
typeof(priors)
prior=Factored(Uniform(1,3), Truncated(Normal(0,0.1), 0, 100))
typeof(prior)
typeof(priors)
sample(priors)
rand(priors)
simulation(alpha1, mu1, sigma1)
y
euclidean(x, y)
x
y
alpha1
exit()
ts <- (1,2,3,4)
tst = (1,2,3,4)
tst[1]
tst[4]
thetuple
tuple
tst[3:4]
p
alpha1
mu1
plot(res)
res
typeof(res)
res[1]
res[1][1]
res[1].particles
stephist(res[1].particles)
plot(res[1].particles)
plot(res[4].particles)
plot(res[7].particles)
plot(res[1].particles)
plot(res[1].particles)
stephist(res[1].particles)
