height(tree)
height(tr)
tree.heightstoRoot
tree.heightstotoot
tree.heightstoroot
heightstoroot(tree)
heightstoroot(tree)
heightstoroot(tree).x
heightstoroot(tree).x
heightstoroot(tree)
tst = heightstoroot(tree)
test
tst
tst.x
fieldnames(typeof(tst))
tst.data
tst.axes
tst.axes[1]
tst.axes[1][1]
tst.data[1][1]
tst.data[1]
tst.data
include("testJulia3.jl")
include("testJulia3.jl")
exit()
include("testJulia3.jl")
whos()
whos()
whos()
using JLD2
include("testJulia3.jl")
whos()
who()
whos
include("testJulia3.jl")
varinfo()
@save "test.jld"
exit()
using JLD2
@load "test.jld"
include("testJulia3.jl")
varinfo()
@save "test.jld"
exit()
using JLD2
@load "test.jld"
<<<<<<< Updated upstream
=======
exit()
>>>>>>> Stashed changes
import Pkg; Pkg.add("Distances")
p
<<<<<<< HEAD
=======
>>>>>>> Stashed changes
=======
>>>>>>> main
=======
q()
exit()
>>>>>>> Stashed changes
exit()
plot(test)
test
exit()
x0
using Phylo
plot(tree)
plot(tree)
menura(tree, x0, mat, p, t0=0.0, dt=0.001)
)
typeof(mu1)
using Distributions
using KissABC
prior=Factored(Uniform(1,3), Truncated(Normal(0,0.1), 0, 100))
using KissABC
prior=Factored(Uniform(1,3), Truncated(Normal(0,0.1), 0, 100))
Factored(Truncated(Normal(0, 10), 0),
                 Truncated(Normal(0, 10), 0))
Factored(Truncated(Normal(0, 10), 0))
Truncated(Normal(0, 10), 0)
prior = Truncated(Normal(0.0, 10.0), l=0.0, u=Inf)

prior = Truncated(Normal(0.0, 10.0),0.0, Inf)
exit()
exit()
]
exit()
import Pkg; Pkg.add("PyPlot")
rand(prior1)
rand(prior1)
rand(prior1)
rand(prior1)
exit()
typeof(prior1)
Array{Factored{3}}(undef, 4)
sz
length(alpha_vec)
ndims
npar
priors
 ERROR: UndefVarError: ESS not defined
rand(priors)
rand.(priors)
rand.(priors)
rand(priors[1])
priors
rand.(priors)
priors
rand.(sigma)
sigma
flatten(rand.(alpha))
collect(rand.(alpha))
rand.(alpha)
rand.(alpha)
rand.(alpha)[1,]
rand.(alpha)[1,][1]
rand.(alpha)
i for 1 in rand.(alpha)
[i for 1 in rand.(alpha)]
[i for i in rand.(alpha)]
[i for i in rand.(alpha)[i]]
q()
exit()
tree
x0
length(x)
rand(x0)
x0
rand(Normal(10))
rand(Normal(10, 100))
rand(Normal(10, 100,3))
priors
alpha1
priors = [alpha1, mu1, sigma1]
priors = [alpha1 mu1 sigma1]
priors = [alpha1, mu1, sigma1]
approx_density = ApproxKernelizedPosterior(priors,cost,0.005)
prior=Factored(Uniform(1,3), Truncated(Normal(0,0.1), 0, 100))
ndims
rand(priors)
rand(priors)
tst = smc(priors, cost)
typeof(priors)
prior=Factored(Uniform(1,3), Truncated(Normal(0,0.1), 0, 100))
typeof(prior)
typeof(priors)
sample(priors)
rand(priors)
simulation(alpha1, mu1, sigma1)
y
euclidean(x, y)
x
y
alpha1
exit()
ts <- (1,2,3,4)
tst = (1,2,3,4)
tst[1]
tst[4]
thetuple
tuple
tst[3:4]
p
alpha1
mu1
plot(res)
res
typeof(res)
res[1]
res[1][1]
res[1].particles
stephist(res[1].particles)
plot(res[1].particles)
plot(res[4].particles)
plot(res[7].particles)
plot(res[1].particles)
plot(res[1].particles)
stephist(res[1].particles)
priors
priors[1]
priors.p
priors.p[1]
typeof(priors)
priors.p[3]
?istuple
?is_tuple
test.p = (1,2)
test =()
test.p = (1,2)
plot(res[1].particles)
plot(res[4].particles)
plot(res[8].particles)
plot(res[12].particles)
ressmc
ressmc.p
typeof(ressmc)
ressmc.P
ressmc.W
ressmc.ϵ
ressmc.P
ressmc.P[1]
ressmc.P[1]
ressmc
rssmc.P[1:100]
ressmc.P[1:100]
ressmc.P
ressmc.A
ressmc.P.A
fieldnames(ressmc)
ABCDE()
rand(priors)
Threads.nthreads()
exit()
Threads.nthreads()
Threads.nthreads()
exit()
Threads.nthreads()
priordists
rand(priordists)
rand(priordists)
repeat(priordists, 12)
repeat((priordists), 12)
priors
using JLD2
y
using JLD2
save_object("ABCResults.jld2", res)
test = read("ABCResults.jld2")
test
using JLD2
res
load_object("ABCResults.jld2")
exit()
p[4]
using Distributions
rand(InverseWishart(mat, 10))
using Distributions
rand(InverseWishart(mat, 10))
rand(InverseWishart(10, mat))
mat
rand(InverseWishart(1000, mat))
rand(InverseWishart(3, mat))
rand(InverseWishart(4, mat))
tst = rand(InverseWishart(4, mat))
tst/diag(tst)
tst/diagonal(tst)
cor(InverseWishart(4, mat))
using StatsBase
y
cor(InverseWishart(4, mat))
cor(InverseWishart)
mat
mat/3.0
mat
dim
dim(mat)
using LinearAlgebra
Diagonal(mat)
?repeat
using LinearAlgebra
Is = sqrt.(1.0/Diagonal(mat))
Is = sqrt.(1.0/.Diagonal(mat))
Is = sqrt.(1.0 ./ Diagonal(mat))
mat
mat
Is
mat
cov2cor(mat, Diagonal(mat))
cov2cor(mat, [1,1,1,1])
mat
diag(mat)
cov2cor(mat, diag(mat))
q()
exit()
import Pkg; Pkg.add("JLD2")
(3.0, 3.0, 3.0, 3.0)
p
x0
tspan
p
dt
diffusion(x0, tspan, p)
diffusion(x0, tspan, p)
diffusion(x0, tspan, p)
cov = mat
p
p[4]
cov=p[4]
cov1 = p[4]
dt=0.001
tr = Ultrametric(10)
tree = rand(tr)
genodes(tree)
getnodes(tree)
fieldnames(typeof(tree))
tree.data
plot(tree)
plot(hummers,
    size = (400, 800),
    linecolor = :orange, linewidth = 5,
    markersize = 10, markercolor = :steelblue, markerstrokecolor = :white,
    series_annotations = text.(1:nnodes(hummers), 5, :center, :center, :white,
    tipfont = (4,))
)
plot(tree,
    size = (400, 800),,
    markersize = 10, markercolor = :steelblue, markerstrokecolor = :white,
    series_annotations = text.(1:nnodes(hummers), 5, :center, :center, :white,
    tipfont = (4,))
)
plot(tree,
    size = (400, 800),
    markersize = 10, markercolor = :steelblue, markerstrokecolor = :white,
    series_annotations = text.(1:nnodes(hummers), 5, :center, :center, :white,
    tipfont = (4,))
)
plot(tree,
    size = (400, 800),
    markersize = 10, markercolor = :steelblue, markerstrokecolor = :white,
    series_annotations = text.(1:nnodes(tree), 5, :center, :center, :white,
    tipfont = (4,))
)
plot(tree,
    size = (400, 800),
    markersize = 100, 
    series_annotations = text.(1:nnodes(tree), 5, :center, :center, :white
)
)
nnodes(tree)
1:nnodes(tree)
getnodes(tree)
getbranches(tree)
tree
getbranches(tree)
length(getbranches(tree))
tst = getbranches(tree)
tst[1]
fieldnames(typeof(tst))
tst.x
length(tst.x)
getnodes(tree)
p
putp!(tree, p)
fieldnames(typeof(tree))
tree.nodedict
tree.nodes
fieldnames(typeof(tree))
tree.nodedict
tree.nodes[2]
tree.nodes
fieldnames(typeof(tree))
tree.name
tree.roots
tree.branches
tree.nodes
tree.nodes[11:end]
tree.node
tree.nodes
tree.branches
tree.branches
tree.branches[1]
tree.branches[10]
tree.branches[11]
tree.branches[12]
tree.branches
fieldnames(typeof(tree))
fieldnames(typeof(tree.nodes))
tree.nodedict
fieldnames(typeof(tree.nodes))
fieldnames(typeof(tree))
tree.data
ntips(tree)
tree.branch[1]
tree.branches[1]
tree.branches[end]
tree.other
tree.inbound
tree.node
tree.nodes
tree.nodes[1]
fieldnames(tree.nodes[1])
fieldnames(typeof(tree.nodes[1]))
length(tree.nodes)
fieldnames(typeof(tree.nodes[1]))
tree.nodes[1].inbound
tree.nodes[1].other
fieldnames(typeof(tree.nodes[1].other))
tree.nodes[1].other
fieldnames(typeof(tree.nodes[1].other))
putp!(tree, p)
length(tree.nodes)
putp!(tree, p)
tree.node
tree.nodes
putp!(tree, p)
p
putp!(tree, p)
tree
tree.node[1].data["2"]
tree.nodes[1].data["2"]
tree.nodes[1].data["1"]
fieldnames(typeof(tree.nodes[1]))
fieldnames(typeof(tree.nodes[3]))
putp!(tree, p)
tree
tree.node[1]
tree.nodes[1]
tree.nodes[1].data
tst = tree.nodes[1].data
tst
tst["2"]
tst["2"][1]
tst["2"][2]
tree.nodes
tree.nodes[1].data
tree.nodes[1].data
p1
p2
p
tree.nodes[1].data
length(tree.nodes[1].data)
tree.nodes[1].data
tree.nodes[1].data[1]
tree.nodes[1].data["1"]
tree.nodes[1].data["2"]
tree.nodes[1].other
tree.nodes[1].other[1]
tree.nodes[1].other
tree.nodes[1].data
tree.nodes[1].other
tree.nodes[1].other.data["2"]
tree.nodes[1].other[1]
tree.nodes[1].other.data
tree.nodes[1].other
fieldnames(typeof(tree.nodes[1].other)
)
nodeInit
tree.nodes[1].data
)
tree
exit()
pwd()
pwd()(
)
pwd()
exit()
q()
exit()
exit()
?println
x0 = [1.5, 3; 3, 1.5]
x0 = [1.5, 3 3, 1.5]
x0 = [1.5, 3, 3, 1.5]
x0 = [1.5 3; 3 1.5]
 function drift(du, u, p, t)
            alpha, mu, sigma = p
            ## du .= alpha .* u would be BM with drift
            du = alpha * (mu - u) ## OU-like
        end # drift

        function diff(du, u, p, t)
            alpha, mu, sigma = p
            du = sigma ## would be OU
            ## du .= sqrt.(u) .* sigma ## Cox-Ingersoll-Ross Gamma model
            ## du .= sqrt.(abs.(u .* (ones(length(sigma)) .- u))) .* sigma ## Beta model
        end # diff
?SDE
using GeometricIntegrators
   function v(t, q, v, p)
          λ = p[:λ]
          v[1] = λ*q[1]
          v[2] = λ*q[2]
      end
  
      function B(t, q, B, p, col=0)
          μ = p[:μ]
          if col==0 #whole matrix
              B[1,1] = μ*q[1]
              B[2,1] = μ*q[2]
          elseif col==1
              #just first column
          end
      end
  
      t₀ = 0.
      q₀ = [1., 1.]
      λ  = 2.
      μ  = 1.
      p = (λ=λ, μ=μ)
  
      sde = SDE(v, B, t₀, q₀; parameters=p)
using GeometricIntegrators
p
sde
ode = ODE((t, x, ẋ) -> ẋ[1] = x[1], [1.0]);
int = Integrator(ode, TableauExplicitEuler(), 0.1);
sol = integrate(ode, int, 10);
exit()
exit()
